{$DEFINE RSCLIENT_AUTOFOCUS} // Automaticly gain focus on mouse and key input.
{$DEFINE RSCLIENT_RETARGET} //  Automaticly retarget the client if RS changes handles.

{$IFNDECL WINAPI_CC}
  {$IFDEF CPU386}
    const WINAPI_CC = ' stdcall';
  {$ELSE}
    const WINAPI_CC = ' win64';
  {$ENDIF}
{$ENDIF}

{$IFNDECL ffi_winapi}
  const ffi_winapi = {$IFDEF CPU386}ffi_stdcall{$ELSE}ffi_win64{$ENDIF};
{$ENDIF}

var
  RS_CLIENT_TITLES: TStringArray = ['RuneScape', 'OSBuddy Pro', 'OSBuddy Guest', 'OSBuddy Free', 'RuneLoader', 'SMART'];

type
  TRSClient = record
    Window: PtrUInt;
    Child: PtrUInt;
    PID: UInt64;
    LoseFocusWindow: PtrUInt;

    IsRS: function: Boolean of object;
    MoveMouse: procedure(P: TPoint) of object;
  end;

var
  RSClient: TRSClient;

// Returns the age of the windows process in milliseconds
function TRSClient.Age: Int64; constref
type
  TFileTime = record
    LowDateTime: DWord;
    HighDateTime: DWord;
  end;

  TSystemTime = record
    Year: Word;
    Month: Word;
    DayOfWeek: Word;
    Day: Word;
    Hour: Word;
    Minute: Word;
    Second: Word;
    Millisecond: Word;
  end;

  function OpenProcess(DesiredAccess: DWord; InheritHandle: LongBool; PID: DWord): PtrUInt; static; external 'OpenProcess@kernel32.dll'+WINAPI_CC;
  function CloseHandle(Handle: PtrUInt): LongBool; static; external 'CloseHandle@kernel32.dll'+WINAPI_CC;
  function GetProcessTimes(ProcessHandle: PtrUInt; var CreationTime, ExitTime, KernelTime, UserTime: TFileTime): LongBool; static; external 'GetProcessTimes@kernel32.dll'+WINAPI_CC;
  function FileTimeToSystemTime(const FileTime: TFileTime; var SystemTime: TSystemTime): LongBool; static; external 'FileTimeToSystemTime@kernel32.dll'+WINAPI_CC;
  function FileTimeToLocalFileTime(const FileTime: TFileTime; var LocalFileTime: TFileTime): LongBool; static; external 'FileTimeToLocalFileTime@kernel32.dll'+WINAPI_CC;

  function MilliSecondsBetween(const ANow, AThen: TDateTime): Int64;
  const
    TDateTimeEpsilon = 2.2204460493e-16;
  begin
    Result := Trunc((Abs(ANow - AThen) + TDateTimeEpsilon) * MSecsPerDay);
  end;

  function FileTimeToDateTime(FileTime: TFileTime): TDateTime;
  var
    SystemTime: TSystemTime;
  begin
    FileTimeToLocalFileTime(FileTime, FileTime);
    FileTimeToSystemTime(FileTime, SystemTime);

    Result := Trunc(EncodeDate(SystemTime.Year, SystemTime.Month, SystemTime.Day)) + Abs(Frac(EncodeTime(SystemTime.Hour, SystemTime.Minute, SystemTime.Second, SystemTime.MilliSecond)));
  end;

const
  PROCESS_ALL_ACCESS = $1F0FFF;
var
  Process: PtrUInt;
  ProcessTimes: record Creation, Exit, Kernel, User: TFileTime; end;
begin
  Process := OpenProcess(PROCESS_ALL_ACCESS, False, Self.PID);

  with ProcessTimes do
    GetProcessTimes(Process, Creation, Exit, Kernel, User);

  CloseHandle(Process);

  Result := MilliSecondsBetween(Now(), FileTimeToDateTime(ProcessTimes.Creation));
end;

// Closes the window by terminating the windows process
procedure TRSClient.Close; constref;

  function TerminateProcess(Process: PtrUInt; ExitCode: UInt32): LongBool; static; external 'TerminateProcess@kernel32.dll'+WINAPI_CC;
  function OpenProcess(DesiredAccess: DWord; InheritHandle: LongBool; PID: DWord): PtrUInt; static; external 'OpenProcess@kernel32.dll'+WINAPI_CC;
  function CloseHandle(Handle: PtrUInt): LongBool; static; external 'CloseHandle@kernel32.dll'+WINAPI_CC;

const
  PROCESS_ALL_ACCESS = $1F0FFF;
var
  Process: PtrUInt;
begin
  Process := OpenProcess(PROCESS_ALL_ACCESS, False, Self.PID);
  TerminateProcess(Process, 0);
  CloseHandle(Process);
end;

// Returns true if the window has focus
function TRSClient.HasFocus: Boolean; constref;

  function GetForegroundWindow: PtrUInt; external 'GetForegroundWindow@user32.dll'+WINAPI_CC;

begin
  Result := GetForegroundWindow() = Self.Window;
end;

// Sets window focus
// This seems to be the most reliable way. Windows is a bit weird when trying to set focus of a window you don't own.
procedure TRSClient.SetFocus(Handle: PtrUInt); constref; overload;
const
  SW_SHOW = 5;

  function GetCurrentThreadID: UInt32; static; external 'GetCurrentThreadId@kernel32.dll'+WINAPI_CC;
  function GetWindowThreadProcessID(Handle: PtrUInt; var PID: UInt32): UInt32; static; external 'GetWindowThreadProcessId@user32.dll'+WINAPI_CC;
  function GetForegroundWindow: PtrUInt; static; external 'GetForegroundWindow@user32.dll'+WINAPI_CC;
  function AttachThreadInput(AttachFrom, AttachTo: UInt32; Attach: LongBool): LongBool; static; external 'AttachThreadInput@user32.dll'+WINAPI_CC;
  function ShowWindow(Handle: PtrUInt; ShowType: Int32): LongBool; static; external 'ShowWindow@user32.dll'+WINAPI_CC;
  function BringWindowToTop(Handle: PtrUInt): LongBool; static; external 'BringWindowToTop@user32.dll'+WINAPI_CC;

var
  Current, Thread, PID: UInt32;
begin
  if (not Self.HasFocus()) then
  begin
    Current := GetWindowThreadProcessId(GetForegroundWindow(), PID);
    Thread := GetCurrentThreadId();

    if (Current <> Thread) then
      AttachThreadInput(Current, Thread, True);

    BringWindowToTop(Handle);
    ShowWindow(Handle, SW_SHOW);

    if (Current <> Thread) then
      AttachThreadInput(Current, Thread, False);
  end;
end;

procedure TRSClient.SetFocus; constref; overload;
begin
  Self.SetFocus(Self.Window);
end;

// Targets the RS client, loops though each canvas child until we find a match
// if PID > 0 will only target a window under with the same PID.
function TRSClient.Target: Boolean; overload;
type
  TWindowArray = array of PtrUInt;
  PWindowArray = ^TWindowArray;

  TEnumWindowsFunc__ = function(Window: PtrUInt; Param: Pointer): LongBool;
  TEnumWindowsFunc = native(TEnumWindowsFunc__, ffi_winapi);

  function EnumWindows(Func: TEnumWindowsFunc; Param: Pointer = nil): LongBool; static; external 'EnumWindows@user32.dll'+WINAPI_CC;
  function EnumChildWindows(Handle: PtrUInt; Func: TEnumWindowsFunc; Param: Pointer = nil): LongBool; static; external 'EnumChildWindows@user32.dll'+WINAPI_CC;

  function GetWindowText(Handle: PtrUInt; Buffer: PChar; MaxCount: Int32): Int32; static; external 'GetWindowTextA@user32.dll'+WINAPI_CC;
  function GetWindowThreadProcessID(Handle: PtrUInt; var PID: UInt32): UInt32; static; external 'GetWindowThreadProcessId@user32.dll'+WINAPI_CC;

  function GetClassName(Handle: PtrUInt; Buffer: PChar; MaxCount: Int32): Int32; static; external 'GetClassNameA@user32.dll'+WINAPI_CC;

  function GetWindow(Handle: PtrUInt; Param: Pointer): LongBool; static;
  var
    Arr: PWindowArray;
  begin
    Arr := Param;
    Arr^ += Handle;

    Exit(True);
  end;

  function GetWindowsByTitle(Title: String): TWindowArray;
  var
    Windows: TWindowArray;
    Window: PtrUInt;
    Buffer: array[0..255] of Char;
    Text: String;
  begin
    EnumWindows(@GetWindow, @Windows);

    for Window in Windows do
    begin
      SetLength(Text, GetWindowText(Window, @Buffer[0], Length(Buffer)));
      if (Length(Text) > 0) then
        MemMove(Buffer[0], Text[1], Length(Text));

      if Title in Text then
        Result += Window;
     end;
  end;

  function GetRSWindows(Parent: PtrUInt): TWindowArray;
  var
    Buffer: array[0..255] of Char;
    Text: String;
    Window: PtrUInt;
    Windows: TWindowArray;
  begin
    EnumChildWindows(Parent, @GetWindow, @Windows);

    for Window in Windows do
    begin
      SetLength(Text, GetClassName(Window, @Buffer[0], Length(Buffer)));
      if (Length(Text) > 0) then
        MemMove(Buffer[0], Text[1], Length(Text));

      if (Text = 'SunAwtCanvas') then
        Result += Window;
    end;
  end;

var
  Title: String;
  Window, Child: PtrUInt;
  PID: UInt32;
begin
  if (@Self.IsRS = nil) then
    raise 'IsRS callback not set';

  Self.PID := 0;
  Self.Window := 0;
  Self.Child := 0;

  for Title in RS_CLIENT_TITLES do
    for Window in GetWindowsByTitle(Title) do
      for Child in GetRSWindows(Window) do
      begin
        FreeTarget(0);
        SetTarget(['', Child]);

        if Self.IsRS() then
        begin
          Self.Child := Child;
          Self.Window := Window;
          Self.PID := PID;
          if (Self.LoseFocusWindow = 0) then
            Self.LoseFocusWindow := GetWindowsByTitle('Simba - ')[0];

          Exit(True);
        end;
    end;

  Exit(False);
end;

procedure TRSClient.Update;

  function IsWindow(Handle: PtrUInt): LongBool; static; external 'IsWindow@user32.dll' + WINAPI_CC;

begin
  if (Self.Child > 0) and (not IsWindow(Self.Child)) then
  begin
    WriteLn('TRSClient.Update');

    if (not Self.Target()) then
      raise 'Failed to update RSClient';
  end;
end;

// Targets the first found RS window
// If no RS windows are found the launcher is executed
function TRSClient.Setup(Launcher: String = ''): Boolean;

  function GetJavaExecutable: String;
  var
    SearchPath, Directory: String;
  begin
    for SearchPath in ['C:\Program Files\Java\', 'C:\Program Files (x86)\Java\'] do
      for Directory in GetDirectories(SearchPath) do
        if (Copy(Directory, 1, 3) = 'jre') and (IsStrInArr('java.exe', False, GetFiles(SearchPath + Directory + '\bin\', 'exe'))) then
          Exit(SearchPath + Directory + '\bin\java.exe');
  end;

var
  T: UInt64;
  Process: TProcess;
begin
  if Self.Target() then
    Exit(True);

  if FileExists(Launcher) then
  begin
    Process.Init(nil);

    if 'jar' in Launcher then
      Process.SetCommandLine(Format('"%s" -jar "%s"', [GetJavaExecutable(), Launcher]))
    else
      Process.SetCommandLine(Launcher);

    Process.Execute();
    Process.Free();

    T := GetTickCount() + (5 * 60000);
    while (T > GetTickCount()) do
    begin
      if Self.Target() then
        Exit(True);

      Wait(1000);
    end;
  end;
end;

// Mouses to a random point off the client
procedure TRSClient.MouseOff;
const
  SM_CXSCREEN = 0;
  SM_CYSCREEN = 1;

  function GetSystemMetrics(Index: Int32): Int32; static; external 'GetSystemMetrics@user32.dll'+WINAPI_CC;
  function GetWindowRect(Handle: PtrUInt; Rect: ^TRect): LongBool; static; external 'GetWindowRect@user32.dll'+WINAPI_CC;

var
  R: TRect;
  P: TPoint;
begin
  GetWindowRect(Self.Window, @R);

  repeat
    P.X := Random(GetSystemMetrics(SM_CXSCREEN));
    P.Y := Random(GetSystemMetrics(SM_CYSCREEN));
  until (not PointInBox(P, [R.Left, R.Top, R.Right, R.Bottom]));

  // local to global position
  P.X -= R.Left;
  P.Y -= R.Top;

  if (@Self.MoveMouse = nil) then
    raise 'Mouse callback not set';

  Self.MoveMouse(P);
end;

// Mouses off the client and gives Simba focus
procedure TRSClient.LoseFocus; overload;
begin
  Self.MouseOff();
  Self.SetFocus(Self.LoseFocusWindow);
end;

// Loses focus and waits x millisecoonds
procedure TRSClient.LoseFocus(Time: Int32); overload;
begin
  Self.LoseFocus();

  Wait(Time);
end;

{$include_once rsclient_overrides.simba}

